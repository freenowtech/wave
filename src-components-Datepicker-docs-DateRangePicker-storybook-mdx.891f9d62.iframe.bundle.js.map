{"version":3,"file":"src-components-Datepicker-docs-DateRangePicker-storybook-mdx.891f9d62.iframe.bundle.js","mappings":";;;;;;;;;;;AAqCA;;;;;;;;;;;;;;;;;;AAkBA;;;;;;;;;AASA;AAGA;;;;AAMA;AACA;;;;;;;AASA;AACA;;;;;;;AAsGA","sources":["webpack://@freenow/wave/./src/components/Datepicker/DatepickerRangeInput.tsx"],"sourcesContent":["import { END_DATE, FirstDayOfWeek, FocusedInput, START_DATE } from '@datepicker-react/hooks';\nimport { compareDesc, Locale, parse, startOfDay, endOfDay } from 'date-fns';\nimport React, { ChangeEventHandler, FC, Fragment, useEffect, useMemo, useRef, useState } from 'react';\nimport styled from 'styled-components';\nimport { compose, margin, MarginProps, width, WidthProps } from 'styled-system';\nimport { usePopper } from 'react-popper';\nimport { createPortal } from 'react-dom';\nimport { MediaQueries } from '../../essentials';\nimport { theme } from '../../essentials/theme';\nimport { getSemanticValue } from '../../utils/cssVariables';\nimport { useGeneratedId } from '../../utils/hooks/useGeneratedId';\nimport { ChevronRightIcon } from '../../icons';\nimport { Input } from '../Input/Input';\n\nimport { Datepicker } from './Datepicker';\nimport { isValidDateText } from './utils/isValidDateText';\nimport { HelperText } from '../HelperText/HelperText';\nimport { dateToDisplayText } from './utils/dateToDisplayText';\nimport { useLocaleObject } from './utils/useLocaleObject';\nimport { useOnChange } from './utils/useOnChange';\nimport { Arrow, DatepickerContentContainer } from './DatepickerContentElements';\nimport { DarkScheme, LightScheme } from '../ColorScheme';\nimport { useClosestColorScheme } from '../../utils/hooks/useClosestColorScheme';\n\ntype DateRangerProps = MarginProps & WidthProps;\n\nconst DateRangeWrapper = styled.div.attrs({ theme })<DateRangerProps>`\n    display: inline-flex;\n    align-items: center;\n    position: relative;\n    z-index: 0;\n    width: 100%;\n\n    input {\n        &:focus,\n        &:active {\n            box-shadow: none;\n            border-color: ${getSemanticValue('border-neutral-default')};\n        }\n    }\n\n    .startDate input {\n        border-right: 0;\n        border-top-right-radius: 0;\n        border-bottom-right-radius: 0;\n        text-align: center;\n    }\n\n    .endDate input {\n        border-left: 0;\n        border-top-left-radius: 0;\n        border-bottom-left-radius: 0;\n        text-align: center;\n    }\n\n    ${MediaQueries.small} {\n        width: 14rem;\n\n        .startDate input,\n        .endDate input {\n            text-align: left;\n        }\n    }\n\n    ${compose(margin, width)}\n`;\n\nconst DateArrow = styled(ChevronRightIcon)`\n    position: absolute;\n    left: calc(50% - 0.75rem);\n    z-index: 1;\n`;\n\nconst StartDateFocusedBlock = styled.div`\n    background: ${getSemanticValue('background-element-info-emphasized')};\n    height: 0.25rem;\n    width: calc(50% - 1.5rem);\n\n    position: absolute;\n    bottom: 0;\n    left: 0.75rem;\n`;\n\nconst EndDateFocusedBlock = styled.div`\n    background: ${getSemanticValue('background-element-info-emphasized')};\n    height: 0.25rem;\n    width: calc(50% - 1.5rem);\n\n    position: absolute;\n    bottom: 0;\n    right: 0.75rem;\n`;\n\nexport interface DateRange {\n    startDate?: Date;\n    endDate?: Date;\n}\n\ninterface DatepickerRangeInputProps extends MarginProps, WidthProps {\n    /**\n     * Placeholder for start date.\n     */\n    startPlaceholder?: string;\n    /**\n     * Placeholder for end date.\n     */\n    endPlaceholder?: string;\n    /**\n     * Label for the input.\n     */\n    label?: string;\n    /**\n     * Function that is used when datepicker closes without selected date.\n     */\n    onClose?: () => void;\n    /**\n     * Set the value for the date\n     */\n    value?: DateRange;\n    /**\n     * Function that is used when datepicker selects new date.\n     */\n    onChange?: (change: DateRange) => void;\n    /**\n     * Minimal date to select from.\n     */\n    minDate?: Date;\n    /**\n     * Maximum date to select from.\n     */\n    maxDate?: Date;\n    /**\n     * Accepts a number for first day of the week from 0 (Sunday) to 6 (Saturday).\n     * @default 1\n     */\n    firstDayOfWeek?: FirstDayOfWeek;\n    /**\n     * Function that runs for each date and returns boolean whether date is disabled or not.\n     * @default () => false\n     */\n    isDateBlocked?: (date: Date) => boolean;\n    /**\n     * Used to align the datepicker in relation to input.\n     * Default: left\n     */\n    placement?: 'left' | 'right' | 'center';\n    /**\n     * String to format dates. See the format at [date-fns docs](https://date-fns.org/v2.29.3/docs/format)\n     * @default dd/MM/yyyy\n     */\n    displayFormat?: string;\n    /**\n     * String to define the locale in ISO-639-1\n     * @default en-US\n     */\n    locale?: string;\n    /**\n     * Text to be shown if error filling the input\n     * or fn to be trigger as a callback when error\n     */\n    errorHandler?: (() => void) | string;\n    /**\n     * The id to be assigned to the start date input\n     */\n    startInputId?: string;\n    /**\n     * The id to be assigned to the end date input\n     */\n    endInputId?: string;\n    /**\n     * Show two (`'normal'`) or one (`'compact'`) month in the datepicker\n     * @value `'compact'` displays only a single month\n     * @default 'normal'\n     */\n    variant?: 'compact' | 'normal';\n    /**\n     * Determines whether the datePicker is disabled or not\n     */\n    disabled?: boolean;\n}\n\ninterface DateRangeInputText {\n    startText: string;\n    endText: string;\n}\n\nconst dateRangeToDisplayText = (locale: Locale, displayFormat?: string, dateRange?: DateRange): DateRangeInputText => {\n    if (!dateRange) {\n        return {\n            startText: '',\n            endText: ''\n        };\n    }\n\n    return {\n        startText: dateToDisplayText(locale, displayFormat, dateRange.startDate),\n        endText: dateToDisplayText(locale, displayFormat, dateRange.endDate)\n    };\n};\n\n// https://date-fns.org/v2.12.0/docs/compareDesc\nconst isValidRange = (startDate, endDate) => {\n    if (startDate && endDate) {\n        return compareDesc(startDate, endDate) >= 0;\n    }\n\n    // Range remains valid until both values of the range are set\n    return true;\n};\n\ntype DatepickerPopperPlacement = 'bottom-end' | 'bottom-start' | 'bottom';\n\nconst PLACEMENT_TO_POPPER_PLACEMENT_MAP: {\n    [key in DatepickerRangeInputProps['placement']]: DatepickerPopperPlacement;\n} = {\n    center: 'bottom',\n    left: 'bottom-start',\n    right: 'bottom-end'\n};\n\nconst mapPlacementToPopperPlacement = (placement: DatepickerRangeInputProps['placement']) =>\n    PLACEMENT_TO_POPPER_PLACEMENT_MAP[placement];\n\nconst DatepickerRangeInput: FC<DatepickerRangeInputProps> = ({\n    minDate,\n    maxDate,\n    firstDayOfWeek,\n    isDateBlocked,\n    onClose,\n    startPlaceholder,\n    endPlaceholder,\n    placement = 'left',\n    label,\n    onChange,\n    displayFormat = 'dd/MM/yyyy',\n    locale = 'en-US',\n    value = {},\n    errorHandler,\n    startInputId,\n    endInputId,\n    variant = 'normal',\n    disabled,\n    ...rest\n}) => {\n    const [triggerReference, setTriggerReference] = useState(undefined);\n    const [contentReference, setContentReference] = useState(undefined);\n    const [arrowReference, setArrowReference] = useState(undefined);\n\n    const localeObject = useLocaleObject(locale);\n    const startDateRef = useRef<HTMLInputElement>();\n    const endDateRef = useRef<HTMLInputElement>();\n    // eslint-disable-next-line unicorn/no-null\n    const [focusedInput, setFocusedInput] = useState<FocusedInput>(null);\n    const [inputText, setInputText] = useState<DateRangeInputText>(\n        dateRangeToDisplayText(localeObject, displayFormat, value)\n    );\n    const [error, setError] = useState({ startDate: false, endDate: false });\n    const displayErrorMessage = typeof errorHandler === 'string';\n\n    const mappedPlacement = mapPlacementToPopperPlacement(placement);\n\n    const { styles, attributes } = usePopper(triggerReference, contentReference, {\n        placement: mappedPlacement,\n        modifiers: [\n            {\n                name: 'flip',\n                enabled: true\n            },\n            {\n                name: 'offset',\n                enabled: true,\n                options: {\n                    offset: [0, 15]\n                }\n            },\n            {\n                name: 'arrow',\n                options: { element: arrowReference }\n            }\n        ]\n    });\n\n    const enforcedColorScheme = useClosestColorScheme(triggerReference);\n    const startId = useGeneratedId(startInputId);\n    const endId = useGeneratedId(endInputId);\n\n    useEffect(() => {\n        if (!focusedInput && (error.startDate || error.endDate) && typeof errorHandler === 'function') {\n            errorHandler();\n        }\n    }, [error.startDate, error.endDate, focusedInput]);\n\n    useEffect(() => {\n        setInputText(dateRangeToDisplayText(localeObject, displayFormat, value));\n    }, [value.startDate, value.endDate, displayFormat, localeObject]);\n\n    useEffect(() => {\n        // when the datepicker is open, bring focus to correct input\n\n        switch (focusedInput) {\n            case START_DATE: {\n                if (startDateRef?.current) startDateRef.current.focus();\n\n                break;\n            }\n            case END_DATE: {\n                if (endDateRef?.current) endDateRef.current.focus();\n\n                break;\n            }\n            default:\n                break;\n        }\n    }, [focusedInput]);\n\n    useOnChange(newFocusedInput => {\n        if (!newFocusedInput && onClose) {\n            onClose();\n        }\n    }, focusedInput);\n\n    const handleDateChange = (startDate?: Date, endDate?: Date) => {\n        if (onChange) {\n            onChange({ startDate: startDate && startOfDay(startDate), endDate: endDate && endOfDay(endDate) });\n        }\n    };\n\n    const handleStartDateInputChange: ChangeEventHandler<HTMLInputElement> = ({ target: { value: inputValue } }) => {\n        setInputText({\n            startText: inputValue,\n            endText: inputText.endText\n        });\n\n        const parsedDate = inputValue === '' ? undefined : parse(inputValue, displayFormat, new Date());\n        const validDate = isValidDateText(parsedDate, inputValue, displayFormat);\n        const validRange = isValidRange(parsedDate, value.endDate);\n        const hasError = (!!inputValue && !validDate) || !validRange;\n\n        if (!hasError) {\n            handleDateChange(parsedDate, value.endDate);\n        }\n\n        setError(state => ({\n            ...state,\n            startDate: hasError\n        }));\n    };\n\n    const handleEndDateInputChange: ChangeEventHandler<HTMLInputElement> = ({ target: { value: inputValue } }) => {\n        setInputText({\n            startText: inputText.startText,\n            endText: inputValue\n        });\n\n        const parsedDate = inputValue === '' ? undefined : parse(inputValue, displayFormat, new Date());\n        const validDate = isValidDateText(parsedDate, inputValue, displayFormat);\n        const validRange = isValidRange(value.startDate, parsedDate);\n        const hasError = (!!inputValue && !validDate) || !validRange;\n\n        if (!hasError) {\n            handleDateChange(value.startDate, parsedDate);\n        }\n\n        setError(state => ({\n            ...state,\n            endDate: hasError\n        }));\n    };\n\n    const PortalWrapper = useMemo(() => {\n        if (!enforcedColorScheme) return Fragment;\n        return enforcedColorScheme === 'light' ? LightScheme : DarkScheme;\n    }, [enforcedColorScheme]);\n\n    return (\n        <>\n            <DateRangeWrapper ref={setTriggerReference} {...rest}>\n                <Input\n                    id={startId}\n                    ref={startDateRef}\n                    autoComplete=\"off\"\n                    className=\"startDate\"\n                    data-testid=\"start-date-input\"\n                    label={label}\n                    placeholder={startPlaceholder}\n                    onFocus={() => setFocusedInput(START_DATE)}\n                    // eslint-disable-next-line unicorn/no-null\n                    onBlur={() => setFocusedInput(null)}\n                    value={inputText.startText}\n                    width=\"100%\"\n                    onChange={handleStartDateInputChange}\n                    data-error={error.startDate}\n                    disabled={disabled}\n                />\n                {focusedInput === START_DATE && <StartDateFocusedBlock />}\n                <DateArrow\n                    color={getSemanticValue(disabled ? 'foreground-disabled' : 'foreground-neutral-emphasized')}\n                />\n                <Input\n                    id={endId}\n                    ref={endDateRef}\n                    tabIndex={!inputText.startText ? -1 : 0}\n                    autoComplete=\"off\"\n                    className=\"endDate\"\n                    data-testid=\"end-date-input\"\n                    placeholder={endPlaceholder}\n                    onFocus={() => setFocusedInput(!value.startDate ? START_DATE : END_DATE)}\n                    // eslint-disable-next-line unicorn/no-null\n                    onBlur={() => setFocusedInput(null)}\n                    value={inputText.endText}\n                    onChange={handleEndDateInputChange}\n                    width=\"100%\"\n                    data-error={error.endDate}\n                    disabled={disabled}\n                />\n                {focusedInput === END_DATE && <EndDateFocusedBlock />}\n            </DateRangeWrapper>\n            {displayErrorMessage && (error.startDate || error.endDate) && !focusedInput && (\n                <HelperText mt=\"1\">{errorHandler || `error (${displayFormat})`}</HelperText>\n            )}\n            {focusedInput &&\n                createPortal(\n                    <PortalWrapper>\n                        <DatepickerContentContainer\n                            ref={setContentReference}\n                            style={styles.popper}\n                            {...attributes.popper}\n                        >\n                            <Arrow ref={setArrowReference} style={styles.arrow} {...attributes.arrow} />\n                            <Datepicker\n                                // TODO: refer to https://stash.intapps.it/projects/DS/repos/wave/pull-requests/104/overview?commentId=168382\n                                numberOfMonths={variant === 'normal' && window.innerWidth >= 768 ? 2 : 1}\n                                minBookingDays={1}\n                                startDate={value.startDate}\n                                endDate={value.endDate}\n                                minBookingDate={minDate}\n                                maxBookingDate={maxDate}\n                                firstDayOfWeek={firstDayOfWeek}\n                                focusedInput={focusedInput}\n                                onDatesChange={({ focusedInput: focusedValue, startDate, endDate }) => {\n                                    setFocusedInput(focusedValue);\n                                    handleDateChange(startDate || undefined, endDate || undefined);\n                                }}\n                                isDateBlocked={isDateBlocked}\n                                locale={localeObject}\n                            />\n                        </DatepickerContentContainer>\n                    </PortalWrapper>,\n                    document.body\n                )}\n        </>\n    );\n};\n\nexport { DatepickerRangeInput, DatepickerRangeInputProps };\n"],"names":[],"sourceRoot":""}