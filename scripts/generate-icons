#!/usr/bin/env node

const fs = require('fs');
const path = require('path');

const yargs = require('yargs');
const svgr = require('@svgr/core').default;
const generate = require('@babel/generator').default;
const minimatch = require('minimatch');
const { Project } = require('ts-morph');

const argv = yargs.command('$0 <input>', '', yargs => {
    yargs.positional('input', {
        type: 'string'
    });
    yargs.options({
        output: {
            alias: 'o',
            type: 'string',
            describe: 'output directory where the generated files will be written',
            default: './src/icons'
        },
        recursive: {
            alias: 'r',
            type: 'boolean',
            describe: 'traverse the directory recursively',
            default: false
        },
        'exclude-color-prop': {
            type: 'array',
            describe: 'glob pattern which files should NOT have a color prop',
            default: []
        },
        'exclude-suffix': {
            type: 'array',
            describe: 'glob pattern which files should not have Icon prefix in the name',
            default: []
        }
    });
}).argv;

function template(babel, opts, { imports, componentName, props, jsx, exports }) {
    const header = `// DO NOT EDIT. This file was generated by running \`npm run generate\`.`;

    const libImports = `${opts.colorProp ? "import { getSemanticValue } from '../../utils/cssVariables';" : ''}`;

    const typeDef = `type Props = ${opts.colorProp ? 'IconProps' : "Omit<IconProps, 'color'>"};`;

    const name = generate(componentName).code;
    const nameDecl = `${name}: React.FC<Props>`;

    const iconProps = opts.colorProp ? "({ size = 'medium', color = 'inherit', ...rest})" :
        "({ size = 'medium', ...props})";

    return babel.template.smart({ plugins: ['typescript'] }).ast`
        ${header}

        ${imports}

        ${libImports}
        import { get } from '../../utils/themeGet';
        import { IconProps } from '../IconProps';

        ${typeDef}

        const ${nameDecl}: FC = ${iconProps} => {
            ${opts.colorProp ? 'const props = {...rest, color}' : ''}
            const sizePx = (Number.isFinite(size as number)) ? size : get(\`iconSizes.\${size}\`)(props) || get('iconSizes.medium')(props);
            
            return (
                ${jsx}
            );
        };

        ${exports}`;
}

function getSvgSources(rootPath, { recursive }) {
    const sources = [];

    for (const dirent of fs.readdirSync(rootPath, { withFileTypes: true })) {
        const filePath = path.join(rootPath, dirent.name);

        if (dirent.isDirectory() && recursive) {
            sources.push(...getSvgSources(filePath, { recursive }));
        } else {
            if (path.extname(dirent.name) === '.svg') {
                sources.push(filePath);
            }
        }
    }

    return sources;
}

function addComponentToIndexTs(indexTsPath, componentName) {
    let indexTs;
    try {
        indexTs = project.getSourceFileOrThrow(indexTsPath);
    } catch (e) {
        indexTs = project.createSourceFile(indexTsPath);
    }

    const exportExists = indexTs.getExportDeclarations().some(exportDecl => {
        return exportDecl.getNamedExports().some(namedExport => namedExport.getLastChild().getText() === componentName);
    });

    if (!exportExists) {
        indexTs.addExportDeclaration({
            namedExports: [
                {
                    name: 'default',
                    alias: componentName
                }
            ],
            moduleSpecifier: `./${componentName}`
        });
    }
}

const project = new Project({
    tsConfigFilePath: './tsconfig.json'
});

for (let file of getSvgSources(argv.input, { recursive: argv.recursive })) {
    const jsx = fs.readFileSync(file, 'utf-8');
    const hasSuffix = !argv.excludeSuffix.some(pattern => minimatch(file, pattern));
    const componentName = path
        .basename(file, '.svg')
        .split(/[-\s]+/g)
        .map(v => v[0].toUpperCase() + v.substring(1))
        .concat(hasSuffix ? 'Icon' : '')
        .join('');

    const colorProp = !argv.excludeColorProp.some(pattern => minimatch(file, pattern));

    // these are additional properties that are not included in the svgr config
    // but are needed in the template to render properly
    const additionalConfig = {
        colorProp
    };

    const code = svgr.sync(
        jsx,
        {
            expandProps: 'start',
            plugins: ['@svgr/plugin-svgo', '@svgr/plugin-jsx', '@svgr/plugin-prettier'],
            prettierConfig: {
                parser: 'typescript'
            },
            template,
            svgProps: { width: '{sizePx}', height: '{sizePx}' },
            replaceAttrValues: colorProp
                ? {
                    //  replace default color for the source svg icons (see assets/icons folder)
                      ['#001E3E']: 'currentColor'
                  }
                : {},
            ...additionalConfig
        },
        {
            componentName
        }
    );

    // SVGO generates ids but over multiple svgs they can conflict with each other.
    // As a solution we replace the default prefix with the component name.
    const processedCode = code.replace(/prefix/g, componentName);

    const outputFile = file.replace(path.basename(file), `${componentName}.tsx`).replace(argv.input, argv.output);

    if (!fs.existsSync(outputFile)) {
        fs.mkdirSync(path.dirname(outputFile), { recursive: true });
    }

    fs.writeFile(outputFile, processedCode, err => {
        if (err) {
            console.error(`failed to generate component for ${file}: ${err}`);
        }
    });

    addComponentToIndexTs(`${path.dirname(outputFile)}/index.ts`, componentName);
}

project.save();
